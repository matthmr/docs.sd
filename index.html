<!DOCTYPE html>
<html>
<head>
<title>Documentation - SD</title>
<link rel="alternate icon"
      type="image/png"
      href="/docs.sd/assets/favicon.ico">
</head>
<h1>SD (Programming Language)</h1>
<h3>Resources</h3>
<ul>
<li><a href="https://github.com/matthmr/sd">Language source code</a></li>
<li><a href="https://github.com/matthmr/docs.sd">Website source code</a></li>
<li><a href="/docs.sd/index.html">Index</a></li>
</ul>
<p>This documents the inner workings of the <a href="https://github.com/matthmr/sd">SD language</a>: the
language paradigms and syntax. Not going into too much detail
about implementation.</p>
<p>For in-depth documentation about the language implementation,
go to the <a href="https://github.com/matthmr/sd/tree/master/docs/txt/README">plain text documentation</a> on the SD repository. Do notice,
however, that documents there are <strong>not</strong> hyperlinked and go into
detail about the language stack rather than the language syntax.</p>
<h2>Index</h2>
<ol>
<li><a href="#main-paradigm">Main Paradigm</a></li>
<li><a href="#running-sd">Running SD</a></li>
<li><a href="#syntax">Syntax</a>
<ol>
<li><a href="#scope">Scope</a></li>
</ol>
</li>
</ol>
<h2>Main paradigm</h2>
<p>In the SD programming language, the main paradigm is that objects are
treat as being <strong>resolved</strong> or <strong>structured</strong>. To SD, an object is just
an entry of its object table (which itself is a segment of the
process' heap) that contains some raw data and some type metadata.
If the data is considered &quot;resolved&quot;, that means no further processing
may be needed on that piece of data other than referencing and
dereferencing. An example of that would be an <code>int</code>, <code>char[]</code>, etc.</p>
<p>However, if the data is considered &quot;structured&quot; or &quot;unresolved&quot;, its
content could be that of an <strong>executable</strong>, <strong>class</strong>, <strong>type</strong>, or any other set
of operations (including general <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> branches) that don't have a return
value yet. That in turn makes the object table a sort of <em>virtual memory</em>
for the SD language, with the &quot;resolved&quot; section being the equivalent
of the <code>.data</code> section and the &quot;structured&quot; section being the equivalent
of the <code>.text</code> section but much more general because the parsing of the
source code is done at runtime because the language is interpreted.</p>
<h2>Running SD</h2>
<p>SD is an <strong>interpreted</strong> language which means it needs an interpreter to
execute its source code, in that sense SD could be used as more of a
scripting language like python rather than a general purpose like C or
rust. The default interpreter is <code>sd</code> (a symbolic link to <code>sdread</code>) which
is a compilation result from <code>make parser</code> (see the <a href="https://github.com/matthmr/sd#building">compilation guide</a>).</p>
<p>A dump of SD's object table can be written to a file and read by <code>sd</code>
passing the <code>-s</code> flag. As per convention, SD source code files have <code>.sd</code>
as extension and object table dumps called <em>object files</em> have <code>.sdo</code>
as extension. SD object files are compiled by <code>sdc</code>, another result
of <code>make parser</code>.</p>
<h2>Syntax</h2>
<p>SD has a unique syntax for a scripting language because:</p>
<ol>
<li>Its variables are strongly typed.</li>
<li>There is a distinction between variable declaring / initializing and
(re)assignment.</li>
</ol>
<p>To define a variable in SD you follow:</p>
<pre><code>let? &lt;type&gt; &lt;name&gt; : &lt;value&gt; ;
</code></pre>
<p>As in:</p>
<pre><code>int year : 2022;
string name : &quot;Two Thousand Twenty Two&quot;;
</code></pre>
<p>The <code>let</code> keyword is optional when defining variables as their type can often
be infered by a literal. So <code>int year : 2022;</code> is the same as <code>let year : 2022;</code>.
The same is not true for <strong>structures</strong>, <strong>unions</strong> or <strong>classes</strong>. Say there is a
structure &quot;<code>Year</code>&quot; that has <code>int number, string name</code> fields, to define such
variable one could write:</p>
<pre><code>Year year : [ 2022, &quot;Two Thousand Twenty Two&quot; ];
# or
Year year : {
	$number : 2022;
	$name   : &quot;Two Thousand Twenty Two&quot;;
};
</code></pre>
<p>Field dereference has syntax similar to a directory path, for instance:</p>
<pre><code>year/@number; # 2022
year/@name;   # &quot;Two Thousand Twenty Two&quot;;
</code></pre>
<p>As oposed to traditional '<code>.</code>' notation (<code>year.number</code>, <code>year.name</code>).</p>
<p>Also, as you might have noticed, the '<code>@</code>' operator is used to dereference
variables in SD. By default, if a variable is referenced <strong>without</strong> the '<code>@</code>'
operator, it is passed <strong>by path</strong>. That is, it is the equivalent of a
<em>pass-by-reference</em> instead of a <em>pass-by-value</em> operation.</p>
<p>For instance, in this code:</p>
<pre><code>let year : 2022;
let current_year : year;
let current_year_number : @year;
</code></pre>
<p><code>current_year</code> is an <strong>alias</strong> to <code>year</code>, so any changes to <code>current_year</code> also change
<code>year</code>: they point to the same entry in the object table. In contrast <code>current_year_number</code>
holds the <strong>value</strong> of <code>year</code>: it has a complete separate entry in the object table.</p>
</html>
